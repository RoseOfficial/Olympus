using System;
using FFXIVClientStructs.FFXIV.Client.Game;
using Olympus.Data;

namespace Olympus.Services.Astrologian;

/// <summary>
/// Tracks Astrologian's card system and seals.
/// Manages card draws, plays, and seal collection for Astrodyne.
/// </summary>
public sealed class CardTrackingService : ICardTrackingService
{
    /// <summary>
    /// Gets the currently drawn card type.
    /// </summary>
    public ASTActions.CardType CurrentCard => GetCurrentCard();

    /// <summary>
    /// Gets the currently drawn Minor Arcana card type.
    /// </summary>
    public ASTActions.CardType MinorArcanaCard => GetMinorArcanaCard();

    /// <summary>
    /// Returns true if a card is currently drawn.
    /// </summary>
    public bool HasCard => CurrentCard != ASTActions.CardType.None;

    /// <summary>
    /// Returns true if a Minor Arcana card is available.
    /// </summary>
    public bool HasMinorArcana => MinorArcanaCard != ASTActions.CardType.None;

    /// <summary>
    /// Gets whether we have a Lord of Crowns (damage) or Lady of Crowns (heal).
    /// </summary>
    public bool HasLord => MinorArcanaCard == ASTActions.CardType.Lord;
    public bool HasLady => MinorArcanaCard == ASTActions.CardType.Lady;

    /// <summary>
    /// Gets the number of seals currently collected (0-3).
    /// </summary>
    public int SealCount => GetSealCount();

    /// <summary>
    /// Gets the number of unique seals collected (for Astrodyne optimization).
    /// </summary>
    public int UniqueSealCount => GetUniqueSealCount();

    /// <summary>
    /// Gets whether we have each type of seal.
    /// </summary>
    public bool HasLunarSeal => GetHasSeal(ASTActions.SealType.Lunar);
    public bool HasSolarSeal => GetHasSeal(ASTActions.SealType.Solar);
    public bool HasCelestialSeal => GetHasSeal(ASTActions.SealType.Celestial);

    /// <summary>
    /// Returns true if we can use Astrodyne (have 3 seals).
    /// </summary>
    public bool CanUseAstrodyne => SealCount >= 3;

    /// <summary>
    /// Returns true if we have Divining status (can use Oracle).
    /// </summary>
    public bool HasDiviningStatus => GetHasDiviningStatus();

    /// <summary>
    /// Gets the card type that should be played for a melee DPS target.
    /// </summary>
    public bool IsMeleeCard => CurrentCard == ASTActions.CardType.TheBalance;

    /// <summary>
    /// Gets the card type that should be played for a ranged DPS target.
    /// </summary>
    public bool IsRangedCard => CurrentCard == ASTActions.CardType.TheSpear;

    /// <summary>
    /// Gets the appropriate Play action for the current card.
    /// </summary>
    public uint GetPlayActionId()
    {
        return CurrentCard switch
        {
            ASTActions.CardType.TheBalance => ASTActions.PlayI.ActionId,
            ASTActions.CardType.TheSpear => ASTActions.PlayII.ActionId,
            ASTActions.CardType.Lord => ASTActions.PlayIII.ActionId,
            _ => 0
        };
    }

    /// <summary>
    /// Gets the seal type that would be generated by the current card.
    /// </summary>
    public ASTActions.SealType GetSealForCurrentCard()
    {
        // In Dawntrail, cards generate specific seals
        // This mapping may need adjustment based on actual game behavior
        return CurrentCard switch
        {
            ASTActions.CardType.TheBalance => ASTActions.SealType.Solar,
            ASTActions.CardType.TheSpear => ASTActions.SealType.Lunar,
            _ => ASTActions.SealType.None
        };
    }

    /// <summary>
    /// Gets the current card from the job gauge.
    /// </summary>
    private static unsafe ASTActions.CardType GetCurrentCard()
    {
        try
        {
            var jobGauge = JobGaugeManager.Instance();
            if (jobGauge == null)
                return ASTActions.CardType.None;

            // AST job gauge structure:
            // The exact byte layout depends on FFXIVClientStructs version
            // Typically: card held, seals, Minor Arcana state
            var gaugeData = jobGauge->CurrentGauge;
            var rawGauge = (byte*)&gaugeData;

            // Card type is typically in byte 0 or 1
            // Values: 0 = None, 1 = Balance, 2 = Spear, etc.
            var cardValue = rawGauge[0];

            return cardValue switch
            {
                1 => ASTActions.CardType.TheBalance,
                2 => ASTActions.CardType.TheSpear,
                3 => ASTActions.CardType.Lord,
                4 => ASTActions.CardType.Lady,
                _ => ASTActions.CardType.None
            };
        }
        catch
        {
            return ASTActions.CardType.None;
        }
    }

    /// <summary>
    /// Gets the Minor Arcana card from the job gauge.
    /// </summary>
    private static unsafe ASTActions.CardType GetMinorArcanaCard()
    {
        try
        {
            var jobGauge = JobGaugeManager.Instance();
            if (jobGauge == null)
                return ASTActions.CardType.None;

            var gaugeData = jobGauge->CurrentGauge;
            var rawGauge = (byte*)&gaugeData;

            // Minor Arcana is typically in a different byte
            var minorArcanaValue = rawGauge[1];

            return minorArcanaValue switch
            {
                1 => ASTActions.CardType.Lord,
                2 => ASTActions.CardType.Lady,
                _ => ASTActions.CardType.None
            };
        }
        catch
        {
            return ASTActions.CardType.None;
        }
    }

    /// <summary>
    /// Gets the total number of seals from the job gauge.
    /// </summary>
    private static unsafe int GetSealCount()
    {
        try
        {
            var jobGauge = JobGaugeManager.Instance();
            if (jobGauge == null)
                return 0;

            var gaugeData = jobGauge->CurrentGauge;
            var rawGauge = (byte*)&gaugeData;

            // Count active seals (typically stored as bit flags or individual bytes)
            // This needs verification against actual gauge structure
            int count = 0;
            var sealByte = rawGauge[2]; // Seal data byte

            // Check each seal bit
            if ((sealByte & 0x01) != 0) count++; // Lunar
            if ((sealByte & 0x02) != 0) count++; // Solar
            if ((sealByte & 0x04) != 0) count++; // Celestial

            return count;
        }
        catch
        {
            return 0;
        }
    }

    /// <summary>
    /// Gets the number of unique seals from the job gauge.
    /// </summary>
    private static unsafe int GetUniqueSealCount()
    {
        try
        {
            var jobGauge = JobGaugeManager.Instance();
            if (jobGauge == null)
                return 0;

            var gaugeData = jobGauge->CurrentGauge;
            var rawGauge = (byte*)&gaugeData;

            // Count unique seal types
            int unique = 0;
            var sealByte = rawGauge[2];

            if ((sealByte & 0x01) != 0) unique++; // Has Lunar
            if ((sealByte & 0x02) != 0) unique++; // Has Solar
            if ((sealByte & 0x04) != 0) unique++; // Has Celestial

            return unique;
        }
        catch
        {
            return 0;
        }
    }

    /// <summary>
    /// Checks if a specific seal type is collected.
    /// </summary>
    private static unsafe bool GetHasSeal(ASTActions.SealType sealType)
    {
        try
        {
            var jobGauge = JobGaugeManager.Instance();
            if (jobGauge == null)
                return false;

            var gaugeData = jobGauge->CurrentGauge;
            var rawGauge = (byte*)&gaugeData;

            var sealByte = rawGauge[2];

            return sealType switch
            {
                ASTActions.SealType.Lunar => (sealByte & 0x01) != 0,
                ASTActions.SealType.Solar => (sealByte & 0x02) != 0,
                ASTActions.SealType.Celestial => (sealByte & 0x04) != 0,
                _ => false
            };
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Checks if Divining status is active (Oracle proc).
    /// </summary>
    private static unsafe bool GetHasDiviningStatus()
    {
        // This would check player status effects for the Divining buff
        // For now, return false - actual implementation would use status checks
        return false;
    }

    /// <summary>
    /// Gets the remaining cooldown on Astral Draw.
    /// </summary>
    public unsafe float GetDrawCooldownRemaining()
    {
        try
        {
            var actionManager = ActionManager.Instance();
            if (actionManager == null)
                return 55f; // Assume worst case

            var recastGroup = actionManager->GetRecastGroup(1, ASTActions.AstralDraw.ActionId);
            var recastInfo = actionManager->GetRecastGroupDetail(recastGroup);

            if (recastInfo == null)
                return 0f;

            return recastInfo->Total - recastInfo->Elapsed;
        }
        catch
        {
            return 55f;
        }
    }

    /// <summary>
    /// Gets the remaining cooldown on Divination.
    /// </summary>
    public unsafe float GetDivinationCooldownRemaining()
    {
        try
        {
            var actionManager = ActionManager.Instance();
            if (actionManager == null)
                return 120f;

            var recastGroup = actionManager->GetRecastGroup(1, ASTActions.Divination.ActionId);
            var recastInfo = actionManager->GetRecastGroupDetail(recastGroup);

            if (recastInfo == null)
                return 0f;

            return recastInfo->Total - recastInfo->Elapsed;
        }
        catch
        {
            return 120f;
        }
    }

    /// <summary>
    /// Gets the remaining cooldown on Astrodyne.
    /// </summary>
    public unsafe float GetAstrodyneCooldownRemaining()
    {
        try
        {
            var actionManager = ActionManager.Instance();
            if (actionManager == null)
                return 120f;

            var recastGroup = actionManager->GetRecastGroup(1, ASTActions.Astrodyne.ActionId);
            var recastInfo = actionManager->GetRecastGroupDetail(recastGroup);

            if (recastInfo == null)
                return 0f;

            return recastInfo->Total - recastInfo->Elapsed;
        }
        catch
        {
            return 120f;
        }
    }
}

/// <summary>
/// Interface for card tracking service.
/// </summary>
public interface ICardTrackingService
{
    /// <summary>
    /// Gets the currently drawn card type.
    /// </summary>
    ASTActions.CardType CurrentCard { get; }

    /// <summary>
    /// Gets the currently drawn Minor Arcana card type.
    /// </summary>
    ASTActions.CardType MinorArcanaCard { get; }

    /// <summary>
    /// Returns true if a card is currently drawn.
    /// </summary>
    bool HasCard { get; }

    /// <summary>
    /// Returns true if a Minor Arcana card is available.
    /// </summary>
    bool HasMinorArcana { get; }

    /// <summary>
    /// Gets whether we have Lord of Crowns.
    /// </summary>
    bool HasLord { get; }

    /// <summary>
    /// Gets whether we have Lady of Crowns.
    /// </summary>
    bool HasLady { get; }

    /// <summary>
    /// Gets the number of seals currently collected.
    /// </summary>
    int SealCount { get; }

    /// <summary>
    /// Gets the number of unique seals collected.
    /// </summary>
    int UniqueSealCount { get; }

    /// <summary>
    /// Gets whether we have each type of seal.
    /// </summary>
    bool HasLunarSeal { get; }
    bool HasSolarSeal { get; }
    bool HasCelestialSeal { get; }

    /// <summary>
    /// Returns true if we can use Astrodyne.
    /// </summary>
    bool CanUseAstrodyne { get; }

    /// <summary>
    /// Returns true if we have Divining status.
    /// </summary>
    bool HasDiviningStatus { get; }

    /// <summary>
    /// Gets whether the current card is for melee DPS.
    /// </summary>
    bool IsMeleeCard { get; }

    /// <summary>
    /// Gets whether the current card is for ranged DPS.
    /// </summary>
    bool IsRangedCard { get; }

    /// <summary>
    /// Gets the appropriate Play action for the current card.
    /// </summary>
    uint GetPlayActionId();

    /// <summary>
    /// Gets the seal type that would be generated by the current card.
    /// </summary>
    ASTActions.SealType GetSealForCurrentCard();

    /// <summary>
    /// Gets the remaining cooldown on Astral Draw.
    /// </summary>
    float GetDrawCooldownRemaining();

    /// <summary>
    /// Gets the remaining cooldown on Divination.
    /// </summary>
    float GetDivinationCooldownRemaining();

    /// <summary>
    /// Gets the remaining cooldown on Astrodyne.
    /// </summary>
    float GetAstrodyneCooldownRemaining();
}
