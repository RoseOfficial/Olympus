using System;
using FFXIVClientStructs.FFXIV.Client.Game;

namespace Olympus.Services.Scholar;

/// <summary>
/// Tracks Scholar's Fairy Gauge (Fae Aether).
/// The gauge is generated by using Aetherflow abilities and powers Fey Union.
/// </summary>
public sealed class FairyGaugeService : IFairyGaugeService
{
    /// <summary>
    /// Maximum Fairy Gauge value.
    /// </summary>
    public const int MaxGauge = 100;

    /// <summary>
    /// Gauge cost per Fey Union tick (every 3 seconds).
    /// </summary>
    public const int FeyUnionCostPerTick = 10;

    /// <summary>
    /// Minimum gauge required to start Fey Union (at least one tick).
    /// </summary>
    public const int MinGaugeForFeyUnion = 10;

    /// <summary>
    /// Gets the current Fairy Gauge value (0-100).
    /// </summary>
    public int CurrentGauge => GetFairyGauge();

    /// <summary>
    /// Returns true if we have any Fairy Gauge.
    /// </summary>
    public bool HasGauge => CurrentGauge > 0;

    /// <summary>
    /// Returns true if we have enough gauge to start Fey Union.
    /// </summary>
    public bool CanUseFeyUnion => CurrentGauge >= MinGaugeForFeyUnion;

    /// <summary>
    /// Returns true if the gauge is at or near maximum (90+).
    /// </summary>
    public bool IsNearMax => CurrentGauge >= 90;

    /// <summary>
    /// Returns true if we should use Fey Union to avoid overcapping gauge.
    /// </summary>
    /// <param name="aetherflowStacks">Current Aetherflow stacks that will generate more gauge.</param>
    public bool ShouldUseFeyUnionToPreventOvercap(int aetherflowStacks)
    {
        // Each Aetherflow ability generates 10 gauge
        var potentialGauge = CurrentGauge + (aetherflowStacks * AetherflowTrackingService.FairyGaugePerStack);
        return potentialGauge > MaxGauge;
    }

    /// <summary>
    /// Calculates how many Fey Union ticks we can sustain with current gauge.
    /// Each tick heals for 480 potency every 3 seconds.
    /// </summary>
    public int EstimatedFeyUnionTicks => CurrentGauge / FeyUnionCostPerTick;

    /// <summary>
    /// Calculates the estimated Fey Union duration in seconds.
    /// </summary>
    public float EstimatedFeyUnionDuration => EstimatedFeyUnionTicks * 3f;

    /// <summary>
    /// Gets the Fairy Gauge value from the game's job gauge.
    /// </summary>
    private static unsafe int GetFairyGauge()
    {
        try
        {
            var jobGauge = JobGaugeManager.Instance();
            if (jobGauge == null)
                return 0;

            // Scholar job gauge stores Fairy Gauge in the second byte
            var gaugeData = jobGauge->CurrentGauge;

            // For SCH: byte 0 = Aetherflow stacks, byte 1 = Fairy Gauge
            var rawGauge = (byte*)&gaugeData;
            return rawGauge[1];
        }
        catch
        {
            return 0;
        }
    }
}

/// <summary>
/// Interface for Fairy Gauge tracking service.
/// </summary>
public interface IFairyGaugeService
{
    /// <summary>
    /// Gets the current Fairy Gauge value (0-100).
    /// </summary>
    int CurrentGauge { get; }

    /// <summary>
    /// Returns true if we have any Fairy Gauge.
    /// </summary>
    bool HasGauge { get; }

    /// <summary>
    /// Returns true if we have enough gauge to start Fey Union.
    /// </summary>
    bool CanUseFeyUnion { get; }

    /// <summary>
    /// Returns true if the gauge is at or near maximum.
    /// </summary>
    bool IsNearMax { get; }

    /// <summary>
    /// Returns true if we should use Fey Union to avoid overcapping gauge.
    /// </summary>
    bool ShouldUseFeyUnionToPreventOvercap(int aetherflowStacks);

    /// <summary>
    /// Calculates how many Fey Union ticks we can sustain.
    /// </summary>
    int EstimatedFeyUnionTicks { get; }

    /// <summary>
    /// Calculates the estimated Fey Union duration in seconds.
    /// </summary>
    float EstimatedFeyUnionDuration { get; }
}
